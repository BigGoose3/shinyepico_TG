---
title: "ÉPICo analysis report"
output: html_document
params:
  #input 
  rval_sheet: NA
  rval_sheet_target: NA
  name_var: NA
  grouping_var: NA
  donor_var: NA
  
  #normalization 
  normalization_mode: NA
  
  #DMP 
  limma_voi: NA
  limma_covar: NA
  limma_arrayweights: NA
  limma_ebayes_trend: NA
  limma_ebayes_robust: NA
  

  rval_design: NA
  rval_contrasts: NA
  
  #heatmap 
  min_deltabeta: NA
  max_fdr: NA
  max_pvalue: NA
  clusteralg: NA
  groups2plot: NA
  contrasts2plot: NA
  Colv: NA
  distance: NA
  scale: NA
  
  
  #plots

  plot_densityplotraw: NA
  plot_densityplot: NA
  plot_pcaplot: NA
  plot_heatmapsnps: NA
  plot_corrplot: NA
  plot_boxplotraw: NA
  plot_boxplot: NA
  plot_qcraw: NA
  plot_bisulfiterawII: NA
  plot_sexprediction: NA
  plot_snpheatmap: NA
  plot_plotSA: NA
  
  table_pcaplot: NA  
  data_sexprediction: NA
  
  table_dmps: NA
  filteredlist2heatmap : NA
---

This report was created with ShinyÉPICo. <br>
(c) 2020 Octavio Morante-Palacios

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


## Variable and samples selection

The group variable selected was __`r params$grouping_var`__, and the donor variable was __`r params$donor_var`__ .

Finally, the selected samples added to the RGSet file were:

```{r sample_sheet, echo=FALSE, warning=FALSE, message = FALSE}
DT::datatable(params$rval_sheet_target, extensions = 'Buttons',
    options = list(dom = 'Blfrtip',
    buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
    lengthMenu = list(c(10,25,50,-1),
    c(10,25,50,"All"))))
```

The following samples were excluded for the analysis:

```{r samples_excluded, echo=FALSE, warning=FALSE, message = FALSE, comment=NA}

cat(params$rval_sheet[[params$name_var]][!(params$rval_sheet[[params$name_var]] %in% params$rval_sheet_target[[params$name_var]])], 
    sep = ", ")

```

<br>

## Bad probes filtering

Before Minfi Normalization, probes in RGChannelSet are filtered using a standard p.value threshold (0.01):

```{r bad_probes, eval=FALSE, echo=TRUE}
RGSet [(rowMeans(as.matrix(minfi::detectionP(RGSet))) <0.01),]
```

<br>

## QC and Array Normalization

The selected normalization method was __`r params$normalization_mode`__. In the next plots, we can see the comparison of the processed data with the raw data.

<br>

### QC Signal plot

In this plot, the average methylated signal vs the average unmethylated signal of each sample is represented. Both average signals should be higher than the signal threshold (10) to be considered OK. Lower or very variable signals can reflect problems in the sample material or in the scanning, but the user is responsible for deciding whether a sample should be excluded.

```{r qc_signal_plot, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_qcraw
```

### QC Bisulfite Conversion plot

Illumina 450k and EPIC arrays have probes to determine if bisulfite conversion has been successful or not. In this graph, the minimum ratio of converted/non-converted signal of bisulfite conversion II probes for each sample is represented.

```{r bisulfite_conversion_plot, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_bisulfiterawII

```

### Density plot  

__Raw__

```{r density_plot_raw, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_densityplotraw
```

__Processed (`r params$normalization_mode`)__

```{r density_plot_processed, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_densityplot
```


<br>

### Boxplot

__Raw__

```{r boxplot_raw, echo=FALSE, warning=FALSE, message = FALSE}
   params$plot_boxplotraw
```

__Processed (`r params$normalization_mode`)__

```{r boxplot_processed, echo=FALSE, warning=FALSE, message = FALSE}
   params$plot_boxplot
```

### Principal Component Analysis

Plot of PCA is shown, with the selected principal components.

```{r pca, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_pcaplot
knitr::kable(params$table_pcaplot)

```

### Correlations

Correlating principal components with variables we can determine if Beta values are related to our variable of interest or other variables. This can also be useful to determine possible errors in the sample hybridization randomization and to select covariables to add to the linear model.


```{r corrplot, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_corrplot
```

(Not useful variables are discarded and the variable type is autodetected. For more information about the methods please read the user guide.)

### SNPs Heatmap

The methylation array has 65 specific SNP probes. These SNP probes are intended to be used for sample tracking and sample mixups. Each SNP probe ought to have values clustered around 3 distinct values corresponding to homo-, and hetero-zygotes. Therefore, different samples of the same donor should cluster together.

__Processed (`r params$normalization_mode`)__

```{r snps_heatmap, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_snpheatmap
```

### Sex Prediction

Depending on the average chromosome Y signal and the average chromosome X signal is possible to predict the sex of the sample donors.

```{r sex_prediction, echo=FALSE, warning=FALSE, message = FALSE}
params$plot_sexprediction
knitr::kable(data.frame(name=params$rval_sheet_target[[params$name_var]],sex=params$data_sexprediction))
```

## Preprocessing 

After Minfi normalization, we obtained a GenomicRatioSet with some transformations depending on the type of normalization chosen. To understand better the different classes of Minfi packages, and their relations depending of the normalization method, please read this [vignette](https://www.bioconductor.org/help/course-materials/2015/BioC2015/methylation450k.html) of Minfi creators (it is also valid for Illumina EPIC arrays).

Moreover, we also removed SNP loci and added Sex information:

```{r dropsnps, eval=FALSE, echo=TRUE}
minfi::addSex(minfi::dropLociWithSnps(gset, maf = 0))

```

<br>

## Differentially Methylated Positions (DMPs) calculation

Then, the linear model was generated using __`r params$limma_voi`__ as variable of interest and __`r if(length(params$limma_covar) == 0) "None" else paste(params$limma_covar, collapse=", ")`__ as covariables to block.

The resulting design matrix was:

```{r design, echo=FALSE, warning=FALSE, message = FALSE}
  knitr::kable(params$rval_design)
```

Optionally, ArrayWeights can be activated to weigh the value of each sample depending on their adjust to the linear model:

```{r limma, echo=TRUE, eval=FALSE}

      if (as.logical(input$select_limma_weights)){
        try({weights = limma::arrayWeights(rval_gset_getM(), design = design})
      }
        else { weights = NULL}
        
      fit = limma::lmFit(MValues, design, weights = weights)

```

Where `weights` is the option specified in the form. In this case, weights is  __`r params$limma_arrayweights`__ .


The relation variance/average of the fit model was:
```{r fit, echo=FALSE, warning=FALSE, message = FALSE}
  params$plot_plotSA

```

With this sample groups, the possible contrasts were:

```{r contrasts, echo=FALSE, warning=FALSE, message = FALSE, comment = NA}

cat(params$rval_contrasts, sep = "\n")

```

Using the calculated model, the t-statistics and p.values are obtained automatically for each contrast:

```{r ebayes, eval=FALSE, echo=TRUE}
  mcontrast = makeContrasts(contrasts=contrast, levels = design)
  fitting = contrasts.fit(fit, mcontrast)
  fitting = eBayes(fitting, trend=trend, robust=robust)
  toptable = topTable(fitting, coef= 1,  adjust.method = "fdr", number =  Inf)

```

Where `trend` and `robust` are the options specified in the form. In this case, trend is  __`r params$limma_ebayes_trend`__ and robust is __`r params$limma_ebayes_robust`__ .


## Filtered results

For each contrast specified ( __`r paste(params$rval_contrasts, collapse=",")`__ ) , the statistics for each CpG were generated and, after, filtered with these criteria:

* Max. FDR: __`r params$max_fdr`__
* Min. Δβ:   __`r params$min_deltabeta`__
* Max. pvalue:   __`r params$max_pvalue`__
* Column dendogram:  __`r params$Colv`__
* Scale: __`r params$scale`__
* Cluster Algorithm: __`r params$clusteralg`__
* Distance: __`r params$distance`__

### Table with all contrasts

```{r filtered_table_all,echo=FALSE,message=FALSE, warning=FALSE}
knitr::kable(params$table_dmps)
```

### Custom heatmap

In the custom heatmap the selected contrasts to plot were: __`r paste(params$contrasts2plot, collapse=", ")`__ and the groups were: __`r paste(params$groups2plot, collapse=", ")`__  )

```{r filtered_table,echo=FALSE,message=FALSE, warning=FALSE, fig.width = 9, fig.height = 12}

rval_voi = params$rval_sheet_target[[params$limma_voi]]

if(!is.null(params$filteredlist2heatmap))
  create_heatmap(params$filteredlist2heatmap, factorgroups =  factor(rval_voi[rval_voi %in%         params$groups2plot], levels = params$groups2plot), groups2plot = rval_voi %in% params$groups2plot, Colv = as.logical(params$Colv), clusteralg = params$clusteralg, distance = params$distance, scale = params$scale, static=TRUE) else
  cat("Differences are not in the plotting range (<10000, >1)")
  
```

<br>

## System and analysis information

This report was generated at __`r Sys.time()`__.

The session information was the following:

```{r system_info, echo=FALSE, message=FALSE, warning=FALSE, comment=NA}
print(sessionInfo())
```






